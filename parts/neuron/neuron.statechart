Neuron[]
    interface
        g.neuron(svg=true)
            g.neuron-inner(svg=true)
                draw Axon
                draw Nucleus
                draw Terminal
                draw Pulse
                draw Motor.TransientPulse
            draw Label

    Type!*
        Normal*
        Motor
            TransientPulse*
                interface
                    _p: 0
                    _strength: @Nucleus.Interaction.elapsed
                    _pos: lib.neuron.axon.position(_p, Neuron)
                    _deg: lib.neuron.axon.angle(Neuron) * 180 / lib.PI()
                    _transform: "rotate({{_deg}}, {{_pos.x}}, {{_pos.y}})"
                    _r: 10 + _strength / 3
                    _rx: _r * 1.2 + 4
                    _ry: _r

                    g.transient-pulse(svg=true)
                        if lib.in(Nucleus.Interaction.DragOrClick) && _strength > 0
                            ellipse.pulse.transient(svg=true, cx=_pos.x, cy=_pos.y, rx=_rx, ry=_ry, transform=_transform)

        Logic
        Memory
        Language
        Autonomic

    Interaction* :: Interactions.MaybeDrag
        None*
            on Neuron.mouse.down (event.button == 0 && event.mod.shift) -> DragOrClick
                view_x: event.view_x
                view_y: event.view_y
                node: event.node
        Dragging
            @nx: @Nucleus.x
            @ny: @Nucleus.y
            @tx: @Terminal.x
            @ty: @Terminal.y

            on any.mouse.move
                _dx: event.view_x - @start_x
                _dy: event.view_y - @start_y
                @Nucleus.x: @nx + _dx
                @Nucleus.y: @ny + _dy
                @Terminal.x: @tx + _dx
                @Terminal.y: @ty + _dy
    Nucleus*
        @x: 0
        @y: 0

        on (lib.changed(@x, @y))
            send redraw to Axon

        interface
            g.nucleus(svg=true)
                circle(svg=true, cx=@x, cy=@y, r=30)

        Interaction* :: Interactions.MaybeDrag
            @elapsed: 0
            None*
                on Nucleus.mouse.down (event.button == 0 && !event.mod.shift) -> DragOrClick
                    view_x: event.view_x
                    view_y: event.view_y
                    node: event.node
                    @elapsed: 0
            DragOrClick
                on any.mouse.up (event.button == 0)
                    add Pulse
                        @strength: @elapsed

                on tick
                    @elapsed: @elapsed + 1
            Dragging
                on any.mouse.move
                    @x: event.view_x - @off_x
                    @y: event.view_y - @off_y

    Axon*
        @path: ""

        on redraw
            @path: lib.neuron.axon.path(Neuron)

        interface
            g.axon(svg=true)
                path(svg=true, d=@path)

    Terminal*
        @x: 0
        @y: 0

        on (lib.changed(@x, @y))
            send redraw to Axon

        interface
            g.terminal(svg=true)
                circle(svg=true, cx=@x, cy=@y, r=30)

        Interaction* :: Interactions.MaybeDrag
            None*
                on Terminal.mouse.down (event.button == 0 && !event.mod.shift) -> DragOrClick
                    view_x: event.view_x
                    view_y: event.view_y
                    node: event.node
            Dragging
                on any.mouse.move
                    @x: event.view_x - @off_x
                    @y: event.view_y - @off_y

    Out
        @action: ""
        @delay: 100

    Label
        @content: ""
        @p: 0
        @side: 0

        interface
            _pos: lib.neuron.axon.position(@p, Neuron)
            _deg: Math.round(lib.neuron.axon.angle(Neuron) * 180 / lib.PI()) + 90 - @side * 180
            _transform: "rotate({{_deg}}, {{_pos.x}}, {{_pos.y}})"
            g.label(svg=true)
                rect.tape(svg=true, x=_pos.x - 6, y = _pos.y - 15, width=100, height=30, transform=_transform)
                text(svg=true, x=_pos.x + 10, y=_pos.y, transform=_transform) {{@content}}

    Pulse[]
        @p: 0
        @speed: 10

        // Used in motor puzzles
        @strength: 1

        on tick
            @p: @p + @speed / lib.neuron.axon.length(Neuron)

        // Outputs
        on tick (@p >= 1 && lib.in(Neuron.Out))
            _: lib.wait(@Neuron.Out.delay, @Neuron.Out.action, 0, "strength", @strength)

        on tick (@p >= 1)
            _: lib.neuron.pulse.propagate(Pulse, Neuron, App)
            remove Pulse

        interface
            _pos: lib.neuron.axon.position(@p, Neuron)
            _deg: lib.neuron.axon.angle(Neuron) * 180 / lib.PI()
            _transform: "rotate({{_deg}}, {{_pos.x}}, {{_pos.y}})"
            _r: 10 + lib.ternary(lib.in(Neuron.Type.Motor), @strength / 6, 0)
            _rx: _r * 1.2 + 4
            _ry: _r
            ellipse.pulse(svg=true, cx=_pos.x, cy=_pos.y, rx=_rx, ry=_ry, transform=_transform)
